# React Router 7 and Remix Development Guidelines

Remix was merged into React Router 7 (framework mode) in late 2024.

## Core Library Imports

- Do not import any packages from `@remix-run` - use `react-router` or `@react-router` instead
- When in doubt, refer to other route components in the `routes` folder

## Returning Data in Loaders and Actions

- **Loaders**: Simply return plain objects - the `json()` helper is deprecated
- **Actions**: Return plain objects for success responses
- **Error Responses**: Use `throw new Response()` for HTTP errors with status codes

```typescript
// ✅ Good - Return plain objects
export async function loader({ params }: Route.LoaderArgs) {
  const data = await getData(params.id);
  return { success: true, data };
}

export async function action({ request }: Route.ActionArgs) {
  try {
    await updateData();
    return { success: true, message: 'Updated successfully' };
  } catch (error) {
    throw new Response('Update failed', { status: 500 });
  }
}

// ❌ Bad - Don't use json() wrapper (deprecated)
export async function loader() {
  return json({ data: 'value' }); // Don't do this
}
```

## Creating Route Components

- Create entry in `routes.ts`
- Create component in `routes/some-route.tsx`
- Export `loader` function for all routes and `action` for routes with forms
- Export `meta` and `handle` for metadata:

```typescript
export const meta: MetaFunction<typeof loader> = ({ data }) => {
  const { automation } = data as Awaited<ReturnType<typeof loader>>;
  return [{ title: `Automation: ${automation?.title ?? 'Not Found'}` }];
};

export const handle = {
  title: 'Betting Tips Evaluation',
  backTo: '/dashboard',
};
```

## Nested Routes

- Parent routes must expose `<Outlet/>` component
- Hide parent components on child routes using location:

```typescript
import { Outlet, useLocation } from 'react-router';

export default function AutomationsIndex() {
  const location = useLocation();
  return (
    <div className="container mx-auto p-4">
      <Outlet />
      {location.pathname === '/automations' && (
        <span>I'm only rendered on the parent route</span>
      )}
    </div>
  );
}
```

## Route Type Imports

- Always import `Route` type from generated `+types` directory
- Do not fix linter errors on type imports - these are generated by dev server
- Never create these type files manually

```typescript
import type { Route } from './+types/some.route';

export async function loader({ request }: Route.LoaderArgs) {
  // ...
}

export async function action({ request }: Route.ActionArgs) {
  // ...
}
```

## Forms with Conform and Zod

### Schema Definition

```typescript
const NestedObjectSchema = z.object({
  fieldA: z.string().optional(),
  fieldB: z.coerce.number().optional(),
});

const FormSchema = z.object({
  mainField: z.string().min(1),
  nested: NestedObjectSchema, // Required object, optional fields
});
```

### Action Function

- Parse `request.formData()` using `parseWithZod`
- Check `submission.status` - if not `'success'`, return `submission.reply()`
- Use `redirectWithToast` on success or `submission.reply({ formErrors: [...] })` on failure

### Component Implementation

- Use `useFetcher<typeof action>()`
- Use Conform's `useForm<z.infer<typeof FormSchema>>({})`
- Provide `lastResult: fetcher.data as SubmissionResult<string[]> | undefined`
- Provide `onValidate({ formData }) { return parseWithZod(formData, { schema: FormSchema }); }`
- For nested fields: `const nestedFields = fields.nested.getFieldset()`

## Multiple Actions with Intents

### Define Intent Constants

```typescript
const INTENT = {
  UPDATE_DETAILS: 'update-details',
  UPLOAD_IMAGE: 'upload-image',
  DELETE_ITEM: 'delete-item',
} as const;
```

### Include Intent in Forms

```tsx
<fetcher.Form method="post">
  <input type="hidden" name="_intent" value={INTENT.UPDATE_DETAILS} />
  {/* other fields */}
  <Button type="submit">Update</Button>
</fetcher.Form>
```

### Route in Action Function

```typescript
export async function action({ request, params }: Route.ActionArgs) {
  const formData = await request.formData();
  const intent = formData.get('_intent');

  switch (intent) {
    case INTENT.UPDATE_DETAILS:
      return handleUpdateDetails(formData, id);
    case INTENT.DELETE_ITEM:
      return handleDeleteItem(formData);
    default:
      return { status: 'error', error: { '': ['Invalid action intent'] } } as SubmissionResult;
  }
}
```

## Debounced Search with Pagination

- Use `useState` for search input value
- Use `useEffect` with `setTimeout` for debouncing
- Use `useNavigate` (not `useSubmit`) inside debounced callback
- Reset page to 1 when searching
- Pass current `searchParams` to pagination component

```typescript
const debouncedNavigate = useCallback(
  (newQuery: string) => {
    const newSearchParams = new URLSearchParams();
    if (newQuery) {
      newSearchParams.set('q', newQuery);
    }
    newSearchParams.set('page', '1');
    navigate(`${location.pathname}?${newSearchParams.toString()}`, { replace: true });
  },
  [navigate, location.pathname],
);

useEffect(() => {
  if (searchQuery === (loaderQuery ?? '')) return;

  const timer = setTimeout(() => {
    debouncedNavigate(searchQuery);
  }, 300);

  return () => clearTimeout(timer);
}, [searchQuery, loaderQuery, debouncedNavigate]);
```

## Component Usage

- Always check `app/components/ui` for generic UI elements
- Check `app/components/features` for feature-specific components
- Ask before creating new reusable components in `app/components`
